Отчет о проделанной работе по теме 
«Методы сортировки»

Библиотека «chrono»

// Получение текущего времени
auto start = high_resolution_clock::now();
//самый точный вариант

// Выполнение какой-то операции
void Function()
{

}

auto end = high_resolution_clock::now();

// Разница между временными точками
auto duration = end — start;
 
Сортировки

Сортировка пузырьком.
Самый стандартный алгоритм сортировки перестановки рядом стоящих не равных друг другу элементов. Если предыдущий меньше последующего — они меняются местами.
Временная сложность:
В лучшем случае — О(n)(массив отсортирован)
В худшем случае — О(n2)
Не требует затрат доп.памяти




Шейкерная сортировка.
Отличается от пузырьковой тем, что проходки по массиву идут как слева направо, так и справа налево.
Временная сложность:
В лучшем случае — О(n)(массив отсортирован)
В худшем случае — О(n2)
Не требует затрат доп.памяти

Сортировка расческой.
Улучшение пузырьковой сортировки. Сравнивает элементы на расстоянии (gap), которое уменьшается на фактор 1.247.
Временная сложность:
В лучшем случае — О(n log2 n)
В худшем случае — О(n2)
Не требует затрат доп.памяти

Сортировка вставками.
Сортировка происходит за счет так называемого „key“ -  элемента,который вставляя в правильную позицию среди уже отсортированных, тем самым, сортируя массив. «Key» изменяется за счет его постоянной переинициализации.
Временная сложность:
В лучшем случае — О(n)(массив отсортирован)
В худшем случае — О(n2)
Не требует затрат доп.памяти

Сортировка выбором 
Находит минимальный элемент в неотсортированной части и меняет его с первым элементом неотсортированной части.
Временная сложность:
Все случаи: O(n²) - всегда делает n(n-1)/2 сравнений
Не требует затрат доп.памяти


Быстрая сортировка 
Выбирает опорный элемент, разделяет массив на две части: элементы меньше опорного и больше опорного, затем с помощью рекурсивного вызова функции, мы сортируем обе части.
Временная сложность:
Лучший - О(n log n)
Худший - О(n2) — опорный эелемент выбирается неудачно, разбивая массив на неравные части
Память - О(n log2 n) — стек рекурсии

Сортировка слиянием 
Делит массив пополам, рекурсивно сортирует каждую половину, затем сливает две отсортированные половины в уже готовый отсортированный массив.
Временная сложность:
Все - О(n log2 n)
Память - О(n) — доп.массив

Сортировка подсчётом 
Подсчитывает количество каждого из элементов в массиве, формирует суммы(количество элементов, которые меньше или равны i, а также позицию, где должен начинаться следующий элемент i в отсортированном массиве.) и на основе этого сортирует массив.
Временная сложность:
Все — О(n+k), где k — диапазон значений
Память О(n+k)





Рандомная сортировка(Bogo sort)
Перемешивает массив случайным образом и проверяет, отсортирован ли он. Если нет - повторяет процесс.
Временная сложность:
Лучший — O(n)
Средний — O(n*n!)
Худший — может никогда не закончиться
Не требует затрат доп.памяти

Сортировка кучей:
Бинарная куча - это полное бинарное дерево, которое удовлетворяет свойству кучи:
    • Max-Heap: Родитель ≥ Потомков
    • Min-Heap: Родитель ≤ Потомков
Последовательно ищем максимальный элемент и переставляем местами, если нарушается правило кучи — используем вспомогательную функцию, тем самым достигая отсортированности массива.
Временная сложность:
Построение кучи — O(n)
Извлечение n элементов: O(n log n)
Общая сложность: O(n log n) во всех случаях
Память: O(1) - сортировка на месте





